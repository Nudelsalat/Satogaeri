%% LaTeX2e file `appendix.tex'
%% generated by the `filecontents' environment
%% from source `CLaTeX' on 2014/11/11.
%%
\chapter{Exemplary SMT code in QF LIA}
\begin{lstlisting}
(set-logic QF_LIA)
(declare-fun f1-1 () Int)
(declare-fun c1-1 () Int)
(declare-fun f1-2 () Int)
(declare-fun c1-2 () Int)
(declare-fun f1-3 () Int)
(declare-fun c1-3 () Int)
(declare-fun f2-1 () Int)
(declare-fun c2-1 () Int)
(declare-fun f2-2 () Int)
(declare-fun c2-2 () Int)
(declare-fun f2-3 () Int)
(declare-fun c2-3 () Int)
(declare-fun f3-1 () Int)
(declare-fun c3-1 () Int)
(declare-fun f3-2 () Int)
(declare-fun c3-2 () Int)
(declare-fun f3-3 () Int)
(declare-fun c3-3 () Int)

(assert (or 
(and (> f1-1 0) (= f1-2 0) (= f1-3 0) (= f2-3 0)) 
(and (= f1-1 0) (> f1-2 0) (= f1-3 0) (= f2-3 0)) 
(and (= f1-1 0) (= f1-2 0) (> f1-3 0) (= f2-3 0)) 
(and (= f1-1 0) (= f1-2 0) (= f1-3 0) (> f2-3 0))))

(assert (or (and (> f2-1 0) (= f3-1 0)) 
(and (= f2-1 0) (> f3-1 0))))

(assert (or (and (> f2-2 0) (= f3-2 0) (= f3-3 0)) 
(and (= f2-2 0) (> f3-2 0) (= f3-3 0)) 
(and (= f2-2 0) (= f3-2 0) (> f3-3 0))))

(assert (and (= c1-1 1) (= c1-3 3) (= c3-1 2)))

(assert (or (= f1-1 c1-1) 
(and (= c1-2 c1-1) (= f1-2 c1-1)) 
(and (= c2-1 c1-1) (= f2-1 c1-1))))

(assert (or (= f1-3 c1-3)))

(assert (or (and (= c3-2 c3-1) (= c3-3 c3-1) (= f3-3 c3-1))))
(check-sat)
(get-value (f1-1))
(get-value (f1-2))
(get-value (f1-3))
(get-value (f2-1))
(get-value (f2-2))
(get-value (f2-3))
(get-value (f3-1))
(get-value (f3-2))
(get-value (f3-3))

Output:
((f1-1 0))
((f1-2 0))
((f1-3 3))
((f2-1 1))
((f2-2 0))
((f2-3 0))
((f3-1 0))
((f3-2 0))
((f3-3 2))
\end{lstlisting}

\chapter{Exemplary SMT code in QF UF}
\begin{lstlisting}
(set-logic QF_UF)
(declare-sort A 0)
(declare-fun zero () A)
(declare-fun f1-1 () A)
(declare-fun c1-1 () A)
(declare-fun f1-2 () A)
(declare-fun c1-2 () A)
(declare-fun f1-3 () A)
(declare-fun c1-3 () A)
(declare-fun f2-1 () A)
(declare-fun c2-1 () A)
(declare-fun f2-2 () A)
(declare-fun c2-2 () A)
(declare-fun f2-3 () A)
(declare-fun c2-3 () A)
(declare-fun f3-1 () A)
(declare-fun c3-1 () A)
(declare-fun f3-2 () A)
(declare-fun c3-2 () A)
(declare-fun f3-3 () A)
(declare-fun c3-3 () A)

(assert (or 
(and (distinct f1-1 zero) (= f1-2 zero) (= f1-3 zero) (= f2-3 zero)) 
(and (= f1-1 zero) (distinct f1-2 zero) (= f1-3 zero) (= f2-3 zero)) 
(and (= f1-1 zero) (= f1-2 zero) (distinct f1-3 zero) (= f2-3 zero)) 
(and (= f1-1 zero) (= f1-2 zero) (= f1-3 zero) (distinct f2-3 zero))))

(assert (or (and (distinct f2-1 zero) (= f3-1 zero)) 
(and (= f2-1 zero) (distinct f3-1 zero))))

(assert (or (and (distinct f2-2 zero) (= f3-2 zero) (= f3-3 zero)) 
(and (= f2-2 zero) (distinct f3-2 zero) (= f3-3 zero)) 
(and (= f2-2 zero) (= f3-2 zero) (distinct f3-3 zero))))

(assert (distinct c1-1 c1-3 c3-1 zero))

(assert (or (= f1-1 c1-1) 
(and (= c1-2 c1-1) (= f1-2 c1-1)) 
(and (= c2-1 c1-1) (= f2-1 c1-1))))

(assert (or (= f1-3 c1-3)))

(assert (or (and (= c3-2 c3-1) (= c3-3 c3-1) (= f3-3 c3-1))))
(check-sat)
(get-value (f1-1))
(get-value (f1-2))
(get-value (f1-3))
(get-value (f2-1))
(get-value (f2-2))
(get-value (f2-3))
(get-value (f3-1))
(get-value (f3-2))
(get-value (f3-3))

(get-value (c1-1))
(get-value (c1-2))
(get-value (c1-3))
(get-value (c2-1))
(get-value (c2-2))
(get-value (c2-3))
(get-value (c3-1))
(get-value (c3-2))
(get-value (c3-3))

Output:
((f1-1 @uc_A_0))
((f1-2 @uc_A_0))
((f1-3 @uc_A_2))
((f2-1 @uc_A_1))
((f2-2 @uc_A_0))
((f2-3 @uc_A_0))
((f3-1 @uc_A_0))
((f3-2 @uc_A_0))
((f3-3 @uc_A_3))

((c1-1 @uc_A_1))
((c1-2 @uc_A_1))
((c1-3 @uc_A_2))
((c2-1 @uc_A_1))
((c2-2 @uc_A_0))
((c2-3 @uc_A_0))
((c3-1 @uc_A_3))
((c3-2 @uc_A_3))
((c3-3 @uc_A_3))
\end{lstlisting}

We know that in f3-3 the circle with the `ID' 3 landed. in the circle-matrix we can trace this `ID' back via c3-3, c3-2 to c3-1. In other words the circle which occupied f3-3 had it's origin in c3-1, which is the `2'-circle.

One can also observe that c1-1, c1-2 and c2-1 share the same `ID' which makes little sense, for a circle cannot move in curves. This is because c2-1 actually never was visited by the `\#'-circle but the solver will give unused fields in the circle-matrix `IDs' at random. Like stated earlier in most cases it will be `0' however there is a chance that it is a different number.

However this is not a real problem, for as long as one tracks from the occupied field back to the origin one will always determine which circle belongs to which country.