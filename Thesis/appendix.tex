%% LaTeX2e file `appendix.tex'
%% generated by the `filecontents' environment
%% from source `CLaTeX' on 2014/11/11.
%%
\chapter{Exemplary SMT code in QF_LIA}
\begin{lstlisting}
(set-logic QF_LIA)
(declare-fun f1-1 () Int)
(declare-fun c1-1 () Int)
(declare-fun f1-2 () Int)
(declare-fun c1-2 () Int)
(declare-fun f1-3 () Int)
(declare-fun c1-3 () Int)
(declare-fun f2-1 () Int)
(declare-fun c2-1 () Int)
(declare-fun f2-2 () Int)
(declare-fun c2-2 () Int)
(declare-fun f2-3 () Int)
(declare-fun c2-3 () Int)
(declare-fun f3-1 () Int)
(declare-fun c3-1 () Int)
(declare-fun f3-2 () Int)
(declare-fun c3-2 () Int)
(declare-fun f3-3 () Int)
(declare-fun c3-3 () Int)

(assert (or 
(and (> f1-1 0) (= f1-2 0) (= f1-3 0) (= f2-3 0)) 
(and (= f1-1 0) (> f1-2 0) (= f1-3 0) (= f2-3 0)) 
(and (= f1-1 0) (= f1-2 0) (> f1-3 0) (= f2-3 0)) 
(and (= f1-1 0) (= f1-2 0) (= f1-3 0) (> f2-3 0))))

(assert (or (and (> f2-1 0) (= f3-1 0)) 
(and (= f2-1 0) (> f3-1 0))))

(assert (or (and (> f2-2 0) (= f3-2 0) (= f3-3 0)) 
(and (= f2-2 0) (> f3-2 0) (= f3-3 0)) 
(and (= f2-2 0) (= f3-2 0) (> f3-3 0))))

(assert (and (= c1-1 1) (= c1-3 3) (= c3-1 2)))

(assert (or (= f1-1 c1-1) 
(and (= c1-2 c1-1) (= f1-2 c1-1)) 
(and (= c2-1 c1-1) (= f2-1 c1-1))))

(assert (= f1-3 c1-3)))

(assert (and (= c3-2 c3-1) (= c3-3 c3-1) (= f3-3 c3-1))))
(check-sat)
(get-value (f1-1))
(get-value (f1-2))
(get-value (f1-3))
(get-value (f2-1))
(get-value (f2-2))
(get-value (f2-3))
(get-value (f3-1))
(get-value (f3-2))
(get-value (f3-3))

Output:
((f1-1 0))
((f1-2 0))
((f1-3 3))
((f2-1 1))
((f2-2 0))
((f2-3 0))
((f3-1 0))
((f3-2 0))
((f3-3 2))
\end{lstlisting}

\chapter{Exemplary SMT code in QF_UF}
\begin{lstlisting}
(set-logic QF_UF)
(declare-sort A 0)
(declare-fun zero () A)
(declare-fun f1-1 () A)
(declare-fun c1-1 () A)
(declare-fun f1-2 () A)
(declare-fun c1-2 () A)
(declare-fun f1-3 () A)
(declare-fun c1-3 () A)
(declare-fun f2-1 () A)
(declare-fun c2-1 () A)
(declare-fun f2-2 () A)
(declare-fun c2-2 () A)
(declare-fun f2-3 () A)
(declare-fun c2-3 () A)
(declare-fun f3-1 () A)
(declare-fun c3-1 () A)
(declare-fun f3-2 () A)
(declare-fun c3-2 () A)
(declare-fun f3-3 () A)
(declare-fun c3-3 () A)

(assert (or 
(and (distinct f1-1 zero) (= f1-2 zero) (= f1-3 zero) (= f2-3 zero)) 
(and (= f1-1 zero) (distinct f1-2 zero) (= f1-3 zero) (= f2-3 zero)) 
(and (= f1-1 zero) (= f1-2 zero) (distinct f1-3 zero) (= f2-3 zero)) 
(and (= f1-1 zero) (= f1-2 zero) (= f1-3 zero) (distinct f2-3 zero))))

(assert (or (and (distinct f2-1 zero) (= f3-1 zero)) 
(and (= f2-1 zero) (distinct f3-1 zero))))

(assert (or (and (distinct f2-2 zero) (= f3-2 zero) (= f3-3 zero)) 
(and (= f2-2 zero) (distinct f3-2 zero) (= f3-3 zero)) 
(and (= f2-2 zero) (= f3-2 zero) (distinct f3-3 zero))))

(assert (distinct c1-1 c1-3 c3-1 zero))

(assert (or (= f1-1 c1-1) 
(and (= c1-2 c1-1) (= f1-2 c1-1)) 
(and (= c2-1 c1-1) (= f2-1 c1-1))))

(assert (= f1-3 c1-3)))

(assert (and (= c3-2 c3-1) (= c3-3 c3-1) (= f3-3 c3-1))))
(check-sat)
(get-value (f1-1))
(get-value (f1-2))
(get-value (f1-3))
(get-value (f2-1))
(get-value (f2-2))
(get-value (f2-3))
(get-value (f3-1))
(get-value (f3-2))
(get-value (f3-3))

(get-value (c1-1))
(get-value (c1-2))
(get-value (c1-3))
(get-value (c2-1))
(get-value (c2-2))
(get-value (c2-3))
(get-value (c3-1))
(get-value (c3-2))
(get-value (c3-3))

Output:
((f1-1 @uc_A_0))
((f1-2 @uc_A_0))
((f1-3 @uc_A_2))
((f2-1 @uc_A_1))
((f2-2 @uc_A_0))
((f2-3 @uc_A_0))
((f3-1 @uc_A_0))
((f3-2 @uc_A_0))
((f3-3 @uc_A_3))

((c1-1 @uc_A_1))
((c1-2 @uc_A_1))
((c1-3 @uc_A_2))
((c2-1 @uc_A_1))
((c2-2 @uc_A_0))
((c2-3 @uc_A_0))
((c3-1 @uc_A_3))
((c3-2 @uc_A_3))
((c3-3 @uc_A_3))
\end{lstlisting}

We know that in f3-3 the circle from c3-1 landed. In the circle-matrix we can trace this `ID' back via c3-3, c3-2 to c3-1. In other words the circle which occupied f3-3 had it's origin in c3-1, which is the `2'-circle.

One can also observe that c1-1, c1-2 and c2-1 share the same `ID' which makes little sense, for a circle cannot move in curves. This is because c2-1 actually never was visited by the `\#'-circle but the solver will assign unused fields in the circle-matrix `IDs' at random. Like stated earlier in most cases it will be `0' however there is a chance that it is a different number.

However this is not a real problem, for as long as one tracks from the occupied field back to the origin, one will always determine which circle belongs to which country.

\chapter{Statistics Output}
These are parts of the output of the CVC4 solver after solving the `bay wolf JR' puzzle.
\lstset{belowskip=-5pt}
\begin{lstlisting}
expr::ExprManager::AND, 1359
expr::ExprManager::EQUAL, 8817
expr::ExprManager::GT, 720
expr::ExprManager::OR, 193
expr::ExprManager::SEXPR, 720
expr::ExprManager::VARIABLE:Integer type, 1440
DefaultModel::constantTermsCount, 0
DefaultModel::functionTermsCount, 0
DefaultModel::mergesCount, 1263
DefaultModel::termsCount, 1360
\end{lstlisting}
 \begin{quote}
   	\center[\ldots]
 \end{quote}
\begin{lstlisting}
sat::clauses_literals, 50140
sat::conflicts, 55
sat::decisions, 1341
sat::learnts_literals, 242
sat::max_literals, 263
sat::propagations, 33499
sat::rnd_decisions, 0
sat::starts, 3
sat::tot_literals, 262
smt::SmtEngine::checkModelTime, 0.000000
smt::SmtEngine::cnfConversionTime, 0.211713
smt::SmtEngine::definitionExpansionTime, 0.180142
smt::SmtEngine::iteRemovalTime, 0.812807
smt::SmtEngine::miplibPassTime, 0.000000
smt::SmtEngine::nonclausalSimplificationTime, 0.154182
smt::SmtEngine::numAssertionsPostITERemoval, 202
smt::SmtEngine::numAssertionsPreITERemoval, 202
smt::SmtEngine::numConstantProps, 0
smt::SmtEngine::numMiplibAssertionsRemoved, 0
smt::SmtEngine::processAssertionsTime, 1.587684
smt::SmtEngine::pushPopTime, 0.000000
smt::SmtEngine::rewriteBooleanTermsTime, 0.100083
smt::SmtEngine::simpITETime, 0.030055
smt::SmtEngine::simplifiedToFalse, 0
smt::SmtEngine::solveTime, 0.259811
smt::SmtEngine::staticLearningTime, 0.061121
smt::SmtEngine::theoryPreprocessTime, 0.415322
smt::SmtEngine::unconstrainedSimpTime, 0.000000
theory::QuantifiersEngine::time, 0.000000
theory::arith::ArithCongruenceManager::constantTermsCount, 0
theory::arith::ArithCongruenceManager::functionTermsCount, 0
theory::arith::ArithCongruenceManager::mergesCount, 4405
theory::arith::ArithCongruenceManager::termsCount, 4826
\end{lstlisting}
 \begin{quote}
   	\center[\ldots]
 \end{quote}
\begin{lstlisting}
theory::arith::UserVariables, 1263
\end{lstlisting}
 \begin{quote}
   	\center[\ldots]
 \end{quote}
\begin{lstlisting}
theory::arith::bound::time, 0.010008
theory::arith::cd::unatePropagateCalls, 9631
theory::arith::cd::unatePropagateImplications, 615
theory::arith::congruence::conflicts, 0
theory::arith::congruence::equalsConstantCalls, 4405
\end{lstlisting}
 \begin{quote}
   	\center[\ldots]
 \end{quote}
\begin{lstlisting}
theory::arith::newPropTimer, 0.069739
theory::arith::pivotTime, 0.000000
theory::arith::pivots, 0
theory::arith::ppRewriteTimer, 0.321978
\end{lstlisting}
 \begin{quote}
   	\center[\ldots]
 \end{quote}
\begin{lstlisting}
theory::arith::presolveTime, 0.803153
theory::arith::restartTimer, 0.000000
theory::arith::simplifyTimer, 0.009655
theory::arith::smallerSetToCurr, 0
theory::arith::staticLearningTimer, 0.030386
theory::arith::status::avgUnknownsInARow, 0.000000
theory::arith::status::commitsOnConflicts, 0
theory::arith::status::maxUnknownsInARow, 0
theory::arith::status::nontrivialSatChecks, 1137
\end{lstlisting}
 \begin{quote}
   	\center[\ldots]
 \end{quote}
\begin{lstlisting}
driver::filename, <stdin>
driver::sat/unsat, sat
driver::totalTime, 1.779003200
\end{lstlisting}